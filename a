


 We have many ways to represent collections of objects using Java's built-in collections as well as collections of your own design. For example if you wanted to represent a set of menu items, we could put those in an array. Or we could do something else like say an ArrayList. Which kind of collection you use depends on your requirements. Now in the real world we'd probably want to represent a menu item by more than just a string. But we'll keep things simple for now. Now say you want to write a print method to print your menus. But what if we want to change the representation of menus in the future.

We'll end up rewriting all that code to print menus because the code depends on the concrete type that we're using. So what else can we do If we know iterations, one aspect of dealing with collections that might change? Let's use the same tactic we've been using and separate what varies and encapsulate it. How? With the iterator pattern. And as we'll see the iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

 As we've seen, we've got two menus with two different implementations. One uses an array and the other, an array list. That means that the class responsible for printing the menus, the Cafe, needs to know the underlying implementation of those menus because it has to use two different methods of iterating through the menus items in order to access the items for printing or some other task. So, the two menus are exposing the details of how they're implemented to the Cafe, which means the Cafe is dependent on those implementations.

And of course, if someone decides later to change how one of the menus is implemented, that will break the code in the Cafe. We can clean up our design and reduce the dependency between the Cafe and the menus by using The Iterator Pattern. Here's the definition of The Iterator Pattern. The pattern gives you a way to access the elements of an aggregate object sequentially without exposing its underlying representation. First, what's an aggregate object? That's just an object that collects things together, using collection type class, like an array or an array list or any of the other java collection classes.

What we want to do is be able to access the elements of an aggregate object without having to know exactly how that aggregate is implemented. In other words, we don't want to have to care that a menu is an array or an array list or any other aggregate type. To accomplish this, the aggregate object provides an iterator object. The iterator object knows how to iterate over the aggregate, but the client, that is, the object using the iterator, doesn't have to know those details.

It just has to know how to ask for and use the iterator. So, to iterate over an aggregate object, the client asks the object for its iterator and then uses that to iterate and because every aggregate object provides the same kind of iterator, the client can use the same code to iterate over any kind of aggregate object. Let's take a look at the class diagram for the iterator pattern and then we'll see how to implement it for the menus.

In our example, the aggregate object is a menu, which uses an array list or array to store the menu items. We have an aggregate interface and a concrete aggregate class that implements that interface, providing a method, createIterator, that creates and returns an iterator object. The client stores that iterator and then, when it needs to iterate over the items in the aggregate object, it can use the two methods defined by the iterator interface to do so. The hasNext method figures out if there are more items to iterate over and the next method just returns the next item.

Here's how we'll design our menus example to use the iterator pattern. Our aggregate object will be the menu. We'll add a menu interface that defines one method, createIterator and both the PancakeHouseMenu and the DinerMenu will implement that menu interface. When the Cafe wants to iterate over the menu items, it will ask the menus for their iterators using the createIterator method. The Cafe doesn't care about how the iterators work under the covers because now, it can use the same interface to iterate over both menus.

The iterators that the two menus create both implement the iterator interface, which specifies the two methods, hasNext and next. So, the specific implementations of how to iterate over the menu items for each type of menu are encapsulated in the two iterators, one for each type of menu. The iterator pattern illustrates an important design principle in object oriented design, the single responsibility principle. This principle states that a class should have only one reason to change.

Let's see how this principle applies to our design. In the original design of the Cafe, the Cafe was responsible for both managing the menus, as well as the details of how to iterate over the menus to access the menu items. In the redesign using the iterator pattern, we've encapsulated the responsibility for the iteration into iterator objects. Now, if we change how a menu is stored, the Cafe doesn't have to change. We simply change the type of the collection in the menu and then use a different iterator.

If the way we're iterating changes, neither the Cafe or the menu has to change. We simply change the way the iteration works in the iterator object. Just like all the other principles we've talked about, the single responsibility principle is designed to help make your designs more resilient to change.
 
 


And of course, if someone decides later to change how one of the menus is implemented, that will break the code in the Cafe. We can clean up our design and reduce the dependency between the Cafe and the menus by using The Iterator Pattern. Here's the definition of The Iterator Pattern. The pattern gives you a way to access the elements of an aggregate object sequentially without exposing its underlying representation. First, what's an aggregate object? That's just an object that collects things together, using collection type class, like an array or an array list or any of the other java collection classes.
